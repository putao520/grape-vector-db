//! ÂçïËäÇÁÇπÊúçÂä°Âô®ÂÆåÊï¥Á§∫‰æã
//! 
//! Ëøô‰∏™Á§∫‰æãÂ±ïÁ§∫‰∫ÜÂ¶Ç‰ΩïÂêØÂä®ÂíåÁÆ°ÁêÜ Grape Vector Database ÁöÑÂçïËäÇÁÇπÊúçÂä°Ôºå
//! ÂåÖÊã¨ gRPC ÊúçÂä°Âô®„ÄÅREST API„ÄÅÁõëÊéßÊåáÊ†áÂíåÂÆ¢Êà∑Á´Ø‰ΩøÁî®„ÄÇ

use grape_vector_db::{
    grpc::{start_grpc_server, VectorDbServiceImpl},
    rest::start_rest_server,
    config::{ServerConfig, VectorConfig, StorageConfig, IndexConfig, MonitoringConfig},
    VectorDatabase, VectorDbConfig,
    types::{Point, SearchRequest, Filter, Condition, FilterOperator},
    metrics::MetricsCollector,
    errors::Result,
};
use std::{
    sync::Arc,
    time::Duration,
    collections::HashMap,
};
use tokio::{
    sync::{RwLock, mpsc},
    time::sleep,
    signal,
};
use tracing::{info, warn, error, debug};
use serde::{Serialize, Deserialize};

/// ÊúçÂä°Âô®ÈÖçÁΩÆÁªìÊûÑ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GrapeServerConfig {
    pub server: ServerConfig,
    pub vector: VectorConfig,
    pub storage: StorageConfig,
    pub index: IndexConfig,
    pub monitoring: MonitoringConfig,
}

impl Default for GrapeServerConfig {
    fn default() -> Self {
        Self {
            server: ServerConfig {
                grpc_port: 6334,
                rest_port: 6333,
                data_dir: "./data".into(),
                log_level: "info".to_string(),
                log_format: "pretty".to_string(),
                worker_threads: num_cpus::get(),
                max_connections: 1000,
                request_timeout_secs: 30,
            },
            vector: VectorConfig {
                dimension: 768,
                distance_metric: "cosine".to_string(),
                binary_quantization: true,
                quantization_threshold: 0.5,
            },
            storage: StorageConfig {
                compression_enabled: true,
                cache_size_mb: 512,
                write_buffer_size_mb: 64,
                max_write_buffer_number: 4,
                target_file_size_mb: 128,
                bloom_filter_bits_per_key: 10,
            },
            index: IndexConfig {
                m: 32,
                ef_construction: 400,
                ef_search: 200,
                max_m: 64,
                max_level: 16,
            },
            monitoring: MonitoringConfig {
                prometheus_enabled: true,
                prometheus_port: 9090,
                health_check_path: "/health".to_string(),
                metrics_interval_secs: 10,
            },
        }
    }
}

/// ÂçïËäÇÁÇπÊúçÂä°Âô®
pub struct GrapeVectorDbServer {
    config: GrapeServerConfig,
    database: Arc<RwLock<VectorDatabase>>,
    metrics: Arc<MetricsCollector>,
    shutdown_tx: mpsc::UnboundedSender<()>,
    shutdown_rx: Option<mpsc::UnboundedReceiver<()>>,
}

impl GrapeVectorDbServer {
    /// ÂàõÂª∫Êñ∞ÁöÑÊúçÂä°Âô®ÂÆû‰æã
    pub async fn new(config: GrapeServerConfig) -> Result<Self> {
        info!("ÂàùÂßãÂåñ Grape Vector Database ÊúçÂä°Âô®...");
        
        // ÂàõÂª∫Êï∞ÊçÆÂ∫ìÈÖçÁΩÆ
        let db_config = VectorDbConfig {
            vector_dimension: config.vector.dimension,
            distance_metric: config.vector.distance_metric.clone(),
            hnsw: grape_vector_db::config::HnswConfig {
                m: config.index.m,
                ef_construction: config.index.ef_construction,
                ef_search: config.index.ef_search,
                max_m: config.index.max_m,
                ml: 1.0 / (2.0_f32.ln()),
                ..Default::default()
            },
            cache: grape_vector_db::config::CacheConfig {
                embedding_cache_size: config.storage.cache_size_mb * 1024,
                query_cache_size: 5000,
                cache_ttl_seconds: 86400,
            },
            ..Default::default()
        };

        // ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ì
        let database = VectorDatabase::with_config(&config.server.data_dir, db_config).await?;
        let database = Arc::new(RwLock::new(database));

        // ÂàùÂßãÂåñÊåáÊ†áÊî∂ÈõÜÂô®
        let metrics = Arc::new(MetricsCollector::new());

        // ÂàõÂª∫ÂÖ≥Èó≠‰ø°Âè∑ÈÄöÈÅì
        let (shutdown_tx, shutdown_rx) = mpsc::unbounded_channel();

        Ok(Self {
            config,
            database,
            metrics,
            shutdown_tx,
            shutdown_rx: Some(shutdown_rx),
        })
    }

    /// ÂêØÂä®ÊúçÂä°Âô®
    pub async fn start(&mut self) -> Result<()> {
        info!("ÂêØÂä® Grape Vector Database ÊúçÂä°Âô®");
        info!("  gRPC Á´ØÂè£: {}", self.config.server.grpc_port);
        info!("  REST Á´ØÂè£: {}", self.config.server.rest_port);
        info!("  Êï∞ÊçÆÁõÆÂΩï: {}", self.config.server.data_dir.display());

        // ÂêØÂä®ÁõëÊéßÊåáÊ†áÊúçÂä°
        if self.config.monitoring.prometheus_enabled {
            self.start_metrics_server().await?;
        }

        // ÂêØÂä® gRPC ÊúçÂä°
        let grpc_handle = self.start_grpc_service().await?;

        // ÂêØÂä® REST API ÊúçÂä°
        let rest_handle = self.start_rest_service().await?;

        // ÂêØÂä®ÁõëÊéß‰ªªÂä°
        let monitoring_handle = self.start_monitoring_task().await;

        info!("üöÄ ÊúçÂä°Âô®ÂêØÂä®ÂÆåÊàêÔºåÁ≠âÂæÖËØ∑Ê±Ç...");

        // Á≠âÂæÖÂÖ≥Èó≠‰ø°Âè∑
        self.wait_for_shutdown().await;

        // ‰ºòÈõÖÂÖ≥Èó≠
        info!("ÂºÄÂßã‰ºòÈõÖÂÖ≥Èó≠...");
        self.graceful_shutdown(grpc_handle, rest_handle, monitoring_handle).await?;

        Ok(())
    }

    /// ÂêØÂä® gRPC ÊúçÂä°
    async fn start_grpc_service(&self) -> Result<tokio::task::JoinHandle<()>> {
        let addr = format!("0.0.0.0:{}", self.config.server.grpc_port).parse()?;
        let database = self.database.clone();
        let metrics = self.metrics.clone();

        let handle = tokio::spawn(async move {
            let service = VectorDbServiceImpl::new(database, metrics);
            
            if let Err(e) = start_grpc_server(service, addr).await {
                error!("gRPC ÊúçÂä°ÂêØÂä®Â§±Ë¥•: {}", e);
            }
        });

        info!("gRPC ÊúçÂä°Â∑≤ÂêØÂä®Âú®Á´ØÂè£ {}", self.config.server.grpc_port);
        Ok(handle)
    }

    /// ÂêØÂä® REST API ÊúçÂä°
    async fn start_rest_service(&self) -> Result<tokio::task::JoinHandle<()>> {
        let addr = format!("0.0.0.0:{}", self.config.server.rest_port);
        let database = self.database.clone();
        let metrics = self.metrics.clone();
        let health_path = self.config.monitoring.health_check_path.clone();

        let handle = tokio::spawn(async move {
            if let Err(e) = start_rest_server(database, metrics, &addr, &health_path).await {
                error!("REST API ÊúçÂä°ÂêØÂä®Â§±Ë¥•: {}", e);
            }
        });

        info!("REST API ÊúçÂä°Â∑≤ÂêØÂä®Âú®Á´ØÂè£ {}", self.config.server.rest_port);
        Ok(handle)
    }

    /// ÂêØÂä®ÁõëÊéßÊåáÊ†áÊúçÂä°
    async fn start_metrics_server(&self) -> Result<()> {
        let addr = format!("0.0.0.0:{}", self.config.monitoring.prometheus_port);
        let metrics = self.metrics.clone();

        tokio::spawn(async move {
            let app = axum::Router::new()
                .route("/metrics", axum::routing::get({
                    let metrics = metrics.clone();
                    move || async move { metrics.export_prometheus() }
                }));

            let listener = tokio::net::TcpListener::bind(&addr).await.unwrap();
            axum::serve(listener, app).await.unwrap();
        });

        info!("Prometheus ÊåáÊ†áÊúçÂä°Â∑≤ÂêØÂä®Âú®Á´ØÂè£ {}", self.config.monitoring.prometheus_port);
        Ok(())
    }

    /// ÂêØÂä®ÁõëÊéß‰ªªÂä°
    async fn start_monitoring_task(&self) -> tokio::task::JoinHandle<()> {
        let database = self.database.clone();
        let metrics = self.metrics.clone();
        let interval_secs = self.config.monitoring.metrics_interval_secs;

        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(interval_secs));
            
            loop {
                interval.tick().await;
                
                // Êî∂ÈõÜÊï∞ÊçÆÂ∫ìÁªüËÆ°‰ø°ÊÅØ
                if let Ok(db) = database.try_read() {
                    let stats = db.stats();
                    
                    // Êõ¥Êñ∞ÊåáÊ†á
                    metrics.update_vector_count(stats.vector_count as f64);
                    metrics.update_memory_usage(stats.memory_usage_mb);
                    metrics.update_cache_hit_rate(stats.cache_hit_rate);
                    
                    debug!("ÊåáÊ†áÊõ¥Êñ∞: {} ‰∏™ÂêëÈáè, {:.2} MB ÂÜÖÂ≠ò", 
                           stats.vector_count, stats.memory_usage_mb);
                }
            }
        })
    }

    /// Á≠âÂæÖÂÖ≥Èó≠‰ø°Âè∑
    async fn wait_for_shutdown(&mut self) {
        let mut shutdown_rx = self.shutdown_rx.take().expect("shutdown_rx should be available");
        
        tokio::select! {
            _ = signal::ctrl_c() => {
                info!("Êî∂Âà∞ Ctrl+C ‰ø°Âè∑");
            }
            _ = shutdown_rx.recv() => {
                info!("Êî∂Âà∞ÂÖ≥Èó≠‰ø°Âè∑");
            }
        }
    }

    /// ‰ºòÈõÖÂÖ≥Èó≠
    async fn graceful_shutdown(
        &self,
        grpc_handle: tokio::task::JoinHandle<()>,
        rest_handle: tokio::task::JoinHandle<()>,
        monitoring_handle: tokio::task::JoinHandle<()>,
    ) -> Result<()> {
        // ÂÅúÊ≠¢Êé•ÂèóÊñ∞ËøûÊé•
        info!("ÂÅúÊ≠¢Êé•ÂèóÊñ∞ËøûÊé•...");
        
        // Á≠âÂæÖÂΩìÂâçËØ∑Ê±ÇÂÆåÊàê
        sleep(Duration::from_secs(2)).await;
        
        // ‰øùÂ≠òÊï∞ÊçÆ
        info!("‰øùÂ≠òÊï∞ÊçÆ...");
        if let Ok(db) = self.database.try_read() {
            db.save().await?;
        }
        
        // ÁªàÊ≠¢ÊúçÂä°‰ªªÂä°
        grpc_handle.abort();
        rest_handle.abort();
        monitoring_handle.abort();
        
        info!("ÊúçÂä°Âô®Â∑≤‰ºòÈõÖÂÖ≥Èó≠");
        Ok(())
    }

    /// ÂèëÈÄÅÂÖ≥Èó≠‰ø°Âè∑
    pub fn shutdown(&self) {
        let _ = self.shutdown_tx.send(());
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // ÂàùÂßãÂåñÊó•ÂøóÁ≥ªÁªü
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();

    info!("üçá Grape Vector Database ÂçïËäÇÁÇπÊúçÂä°Âô®ÂêØÂä®");

    // Ê£ÄÊü•ÂëΩ‰ª§Ë°åÂèÇÊï∞
    let args: Vec<String> = std::env::args().collect();
    let config_path = args.get(1).unwrap_or(&"config.toml".to_string());

    // Âä†ËΩΩÈÖçÁΩÆ
    let config = load_config(config_path).await?;
    info!("ÈÖçÁΩÆÂä†ËΩΩÂÆåÊàê: {}", config_path);

    // ËøêË°åÁ§∫‰æãÊºîÁ§∫
    run_demo().await?;

    // ÂàõÂª∫Âπ∂ÂêØÂä®ÊúçÂä°Âô®
    let mut server = GrapeVectorDbServer::new(config).await?;
    server.start().await?;

    Ok(())
}

/// Âä†ËΩΩÈÖçÁΩÆÊñá‰ª∂
async fn load_config(config_path: &str) -> Result<GrapeServerConfig> {
    if std::path::Path::new(config_path).exists() {
        let content = tokio::fs::read_to_string(config_path).await?;
        let config: GrapeServerConfig = toml::from_str(&content)?;
        Ok(config)
    } else {
        info!("ÈÖçÁΩÆÊñá‰ª∂‰∏çÂ≠òÂú®Ôºå‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ: {}", config_path);
        let config = GrapeServerConfig::default();
        
        // ‰øùÂ≠òÈªòËÆ§ÈÖçÁΩÆÂà∞Êñá‰ª∂
        let content = toml::to_string_pretty(&config)?;
        tokio::fs::write(config_path, content).await?;
        info!("ÈªòËÆ§ÈÖçÁΩÆÂ∑≤‰øùÂ≠òÂà∞: {}", config_path);
        
        Ok(config)
    }
}

/// ËøêË°åÊºîÁ§∫
async fn run_demo() -> Result<(), Box<dyn std::error::Error>> {
    info!("üéØ ËøêË°åÂÆ¢Êà∑Á´ØÊºîÁ§∫...");

    // Á≠âÂæÖÊúçÂä°Âô®ÂêØÂä®
    sleep(Duration::from_secs(1)).await;

    // ÊºîÁ§∫ REST API ÂÆ¢Êà∑Á´Ø
    demo_rest_client().await?;

    // ÊºîÁ§∫ gRPC ÂÆ¢Êà∑Á´Ø
    // demo_grpc_client().await?;

    info!("‚úÖ ÊºîÁ§∫ÂÆåÊàê");
    Ok(())
}

/// REST API ÂÆ¢Êà∑Á´ØÊºîÁ§∫
async fn demo_rest_client() -> Result<(), Box<dyn std::error::Error>> {
    info!("üì° REST API ÂÆ¢Êà∑Á´ØÊºîÁ§∫");

    let client = reqwest::Client::new();
    let base_url = "http://localhost:6333";

    // 1. ÂÅ•Â∫∑Ê£ÄÊü•
    let health_response = client
        .get(&format!("{}/health", base_url))
        .send()
        .await?;
    
    info!("ÂÅ•Â∫∑Ê£ÄÊü•: {}", health_response.status());

    // 2. Ê∑ªÂä†ÂêëÈáè
    let vector_data = serde_json::json!({
        "id": "demo_doc_1",
        "vector": generate_random_vector(768),
        "payload": {
            "title": "ÊºîÁ§∫ÊñáÊ°£1",
            "category": "Á§∫‰æã",
            "language": "zh"
        }
    });

    let add_response = client
        .post(&format!("{}/vectors", base_url))
        .header("Content-Type", "application/json")
        .json(&vector_data)
        .send()
        .await?;

    info!("Ê∑ªÂä†ÂêëÈáè: {}", add_response.status());

    // 3. ÊâπÈáèÊ∑ªÂä†ÂêëÈáè
    let batch_data = serde_json::json!({
        "vectors": [
            {
                "id": "demo_doc_2",
                "vector": generate_random_vector(768),
                "payload": {"title": "ÊºîÁ§∫ÊñáÊ°£2", "category": "ÊâπÈáè"}
            },
            {
                "id": "demo_doc_3", 
                "vector": generate_random_vector(768),
                "payload": {"title": "ÊºîÁ§∫ÊñáÊ°£3", "category": "ÊâπÈáè"}
            }
        ]
    });

    let batch_response = client
        .post(&format!("{}/vectors/batch", base_url))
        .header("Content-Type", "application/json")
        .json(&batch_data)
        .send()
        .await?;

    info!("ÊâπÈáèÊ∑ªÂä†: {}", batch_response.status());

    // 4. ÊêúÁ¥¢ÂêëÈáè
    let search_data = serde_json::json!({
        "vector": generate_random_vector(768),
        "limit": 5,
        "filter": {
            "conditions": [
                {
                    "field": "category",
                    "operator": "eq", 
                    "value": "Á§∫‰æã"
                }
            ]
        }
    });

    let search_response = client
        .post(&format!("{}/vectors/search", base_url))
        .header("Content-Type", "application/json")
        .json(&search_data)
        .send()
        .await?;

    if search_response.status().is_success() {
        let results: serde_json::Value = search_response.json().await?;
        info!("ÊêúÁ¥¢ÁªìÊûú: {} ‰∏™", results["results"].as_array().unwrap_or(&vec![]).len());
    }

    // 5. Ëé∑ÂèñÁªüËÆ°‰ø°ÊÅØ
    let stats_response = client
        .get(&format!("{}/stats", base_url))
        .send()
        .await?;

    if stats_response.status().is_success() {
        let stats: serde_json::Value = stats_response.json().await?;
        info!("Êï∞ÊçÆÂ∫ìÁªüËÆ°: {}", stats);
    }

    Ok(())
}

/// ÁîüÊàêÈöèÊú∫ÂêëÈáè
fn generate_random_vector(dimension: usize) -> Vec<f32> {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    (0..dimension).map(|_| rng.gen_range(-1.0..1.0)).collect()
}

// ‰∏∫‰∫ÜÁºñËØëÈÄöËøáÔºåÊàë‰ª¨ÈúÄË¶ÅÂÆö‰πâ‰∏Ä‰∫õÈÖçÁΩÆÁªìÊûÑ‰Ωì
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServerConfig {
    pub grpc_port: u16,
    pub rest_port: u16,
    pub data_dir: std::path::PathBuf,
    pub log_level: String,
    pub log_format: String,
    pub worker_threads: usize,
    pub max_connections: usize,
    pub request_timeout_secs: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VectorConfig {
    pub dimension: usize,
    pub distance_metric: String,
    pub binary_quantization: bool,
    pub quantization_threshold: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageConfig {
    pub compression_enabled: bool,
    pub cache_size_mb: usize,
    pub write_buffer_size_mb: usize,
    pub max_write_buffer_number: usize,
    pub target_file_size_mb: usize,
    pub bloom_filter_bits_per_key: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndexConfig {
    pub m: usize,
    pub ef_construction: usize,
    pub ef_search: usize,
    pub max_m: usize,
    pub max_level: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MonitoringConfig {
    pub prometheus_enabled: bool,
    pub prometheus_port: u16,
    pub health_check_path: String,
    pub metrics_interval_secs: u64,
}

// ‰∏∫‰∫ÜÊºîÁ§∫ÁõÆÁöÑÁöÑÁÆÄÂåñÂÆûÁé∞
mod simplified_impls {
    use super::*;

    pub async fn start_grpc_server<T>(_service: T, _addr: std::net::SocketAddr) -> Result<()> {
        // ÁÆÄÂåñÁöÑ gRPC ÊúçÂä°Âô®ÂêØÂä®
        info!("gRPC ÊúçÂä°Âô®Ê®°ÊãüÂêØÂä®");
        Ok(())
    }

    pub async fn start_rest_server<T>(_db: T, _metrics: Arc<MetricsCollector>, _addr: &str, _health_path: &str) -> Result<()> {
        // ÁÆÄÂåñÁöÑ REST ÊúçÂä°Âô®ÂêØÂä®
        info!("REST ÊúçÂä°Âô®Ê®°ÊãüÂêØÂä®");
        Ok(())
    }
}

use simplified_impls::*;