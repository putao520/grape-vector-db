## ✅ 编程原则（必须遵守）

1. **遵循 SOLID 原则**  
   - 单一职责、开放封闭、里氏替换、接口隔离、依赖倒置是基础设计原则。

2. **函数单一职责**  
   - 每个函数只执行一项明确的操作，禁止混合多重语义。

3. **异常必须处理**  
   - 所有异常和边界情况必须显式捕获与处理，禁止遗漏。

4. **变量命名清晰自然**  
   - 命名应表达语义，如：`data → userList`，不可使用模糊词、缩写等非语义命名。

---

## 🧠 辅助模式（AI 助手工作方式）

### 核心原则

- **现有实现优先**  
  必须先分析用户当前已有代码结构，在此基础上提出方案，**禁止脱离实现提通用建议**。

- **挖掘架构潜力**  
  优先复用和扩展已有模块或设计，避免无必要重构。

- **第一性原理驱动**  
  所有判断需基于实现的本质目的进行分析，而非引用知识库模板或惯例经验。

---

### 工作方式

- 主动识别用户代码中**可复用的实现与模块**。
- 每次提出优化建议时，提供**2个以上基于当前架构的扩展方案**，并分别分析优劣。
- 注重**边界情况、容错处理、易读性与一致性**。
- 未经用户指令，不自动生成代码，仅做架构分析、组件拆解与方案推荐。

---

## 🔧 SOLID 原则实践方法（抽象通用）

### ✅ SRP - 单一职责原则
- 每个类/模块/函数仅处理一种职责。
- 功能边界清晰，职责不交叉、不重叠。

### ✅ OCP - 开放封闭原则
- 系统对拓展开放、对修改封闭。
- 通过接口/trait/策略模式等实现扩展点。

### ✅ LSP - 里氏替换原则
- 所有实现必须可无缝替代抽象，并保持行为一致性。
- 不得违反父接口定义的行为契约。

### ✅ ISP - 接口隔离原则
- 拆分大型接口为小而专注的接口。
- 调用方只依赖自己实际用到的部分。

### ✅ DIP - 依赖倒置原则
- 上层模块依赖抽象而非具体实现。
- 使用依赖注入、抽象工厂等方式解除耦合。

---

## 🚫 编程底线约束（禁止行为）

1. **禁止添加 TODO 留口子**  
   - 不得提交含 `TODO`、`FIXME` 等待办标记的代码。
   - 所有功能应闭环处理，无未完逻辑残留。

2. **禁止简化需求规避实现**  
   - 不得擅自裁剪功能、弱化边界条件。
   - 所有代码必须完整实现最初设计目标，不得“按测试能过”标准自我缩减。

3. **禁止向测试妥协**  
   - 不得为了让测试通过而修改正确逻辑。
   - 不得跳过关键路径、不写测试或用无效 mock 掩盖缺陷。
