# Grape Vector Database - Cursor AI 规则

## 项目信息

这是一个高性能向量数据库项目，使用Rust开发，目标是成为Qdrant的完整替代方案。

### 当前架构状态
- Phase 1 已完成：核心存储引擎(Sled)、内嵌模式、向量索引(HNSW)、多种嵌入提供商支持
- Phase 2 规划中：分布式架构(Raft共识算法)、集群管理、数据分片

### 核心技术栈
- 存储引擎: Sled (已从RocksDB迁移)
- 向量索引: instant-distance (HNSW算法) 
- 异步运行时: tokio
- 网络通信: tonic(gRPC) + reqwest(HTTP)
- 并发: parking_lot, crossbeam, dashmap
- 缓存: moka
- 错误处理: thiserror + anyhow

## 严格的开发规范 (不可违反)

### 代码质量铁律
1. **SOLID原则**: 每个模块必须遵循单一职责、开闭、里氏替换、接口隔离、依赖反转原则
2. **单一职责**: 每个函数只能专注做一件事，禁止多责任混合
3. **完整实现**: 严禁任何TODO、unimplemented!()、占位符或简化实现，所有功能必须100%完整
4. **异常处理**: 所有可能失败的操作必须显式处理错误，使用Result<T, E>类型
5. **变量命名**: 必须语义明确，禁用data、info、temp、result等泛化名称

### 错误处理标准模式
```rust
use thiserror::Error;
use anyhow::Result;

#[derive(Error, Debug)]
pub enum VectorDbError {
    #[error("向量维度不匹配: 期望 {expected}, 实际 {actual}")]
    DimensionMismatch { expected: usize, actual: usize },
    
    #[error("存储层错误: {0}")]
    Storage(#[from] sled::Error),
    
    #[error("网络请求失败: {0}")]
    Network(#[from] reqwest::Error),
    
    #[error("gRPC通信错误: {0}")]
    Grpc(#[from] tonic::Status),
}
```

### 异步编程规范
- 所有I/O操作强制使用async/await，禁止阻塞调用
- 使用Arc<Mutex<T>>时优先选择parking_lot::Mutex
- 合理使用tokio::spawn避免阻塞主线程
- 网络请求必须设置超时时间

### 内存安全要求
- 避免不必要的.clone()，优先使用引用
- 字符串处理使用Cow<str>减少分配
- 小向量使用smallvec替代Vec
- 大文件操作使用memmap2内存映射

## 架构设计原则

### 模块化设计
每个主要功能必须抽象为trait:

```rust
// 存储层抽象
#[async_trait]
pub trait StorageBackend: Send + Sync {
    async fn store_vector(&self, collection: &str, id: &str, vector: &[f32]) -> Result<()>;
    async fn retrieve_vector(&self, collection: &str, id: &str) -> Result<Option<Vec<f32>>>;
    async fn delete_vector(&self, collection: &str, id: &str) -> Result<bool>;
    async fn list_collections(&self) -> Result<Vec<String>>;
}

// 向量索引抽象  
#[async_trait]
pub trait VectorIndex: Send + Sync {
    async fn add_vector(&mut self, id: String, vector: Vec<f32>) -> Result<()>;
    async fn search(&self, query: &[f32], k: usize, filter: Option<&Filter>) -> Result<Vec<SearchResult>>;
    async fn remove_vector(&mut self, id: &str) -> Result<bool>;
    async fn get_stats(&self) -> Result<IndexStats>;
}

// 嵌入提供商抽象
#[async_trait]
pub trait EmbeddingProvider: Send + Sync {
    async fn embed_text(&self, text: &str) -> Result<Vec<f32>>;
    async fn embed_batch(&self, texts: &[String]) -> Result<Vec<Vec<f32>>>;
    fn dimension(&self) -> usize;
    fn max_batch_size(&self) -> usize;
}
```

### 并发安全设计
- 所有共享状态必须使用Arc包装
- 读多写少场景使用Arc<RwLock<T>>
- 高频访问使用Arc<Mutex<T>>配合parking_lot
- 无锁场景优先使用crossbeam和dashmap

### 分布式架构规划 (Phase 2)
```rust
// Raft节点定义
pub struct RaftNode {
    id: NodeId,
    address: SocketAddr,
    role: NodeRole,
    term: u64,
    log: Vec<LogEntry>,
    commit_index: usize,
    last_applied: usize,
}

// 集群管理
pub struct ClusterManager {
    nodes: Arc<RwLock<HashMap<NodeId, RaftNode>>>,
    leader_id: Arc<RwLock<Option<NodeId>>>,
    election_timeout: Duration,
    heartbeat_interval: Duration,
}
```

## 性能优化指导

### 关键性能指标
- 向量插入性能: > 10K QPS
- 向量搜索性能: > 40K QPS  
- 内存使用: < 2GB (100万向量)
- 缓存命中率: > 85%
- 二进制量化加速: > 40x

### 优化策略
1. **内存优化**: 二进制量化、智能缓存、内存池复用
2. **并发优化**: 无锁数据结构、读写分离、批量操作 
3. **存储优化**: 数据压缩、索引预加载、增量备份
4. **网络优化**: 连接池、请求批处理、gRPC流式传输

## 测试要求

### 必须覆盖的测试类型
```rust
// 单元测试示例
#[cfg(test)]
mod tests {
    use super::*;
    use proptest::prelude::*;
    
    #[tokio::test]
    async fn test_vector_insertion() {
        let db = VectorDatabase::new("./test_data").await.unwrap();
        // 完整测试逻辑...
    }
    
    // 属性测试
    proptest! {
        #[test]
        fn test_search_consistency(
            vectors in prop::collection::vec(
                prop::collection::vec(-1.0f32..1.0, 128..128), 
                1..1000
            )
        ) {
            // 属性测试逻辑...
        }
    }
}

// 性能基准测试
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_search_performance(c: &mut Criterion) {
    c.bench_function("search_10k_vectors", |b| {
        b.iter(|| {
            // 性能测试逻辑
        })
    });
}
```

### 集成测试要求
- 多线程并发安全测试
- 故障恢复测试 
- 大规模数据测试(>100万向量)
- 网络分区测试(分布式场景)

## 代码风格和文档

### 命名规范
- 模块: snake_case (storage_engine, vector_index)
- 结构体: PascalCase (VectorDatabase, SearchResult)
- 函数: snake_case (add_document, search_vectors)  
- 常量: SCREAMING_SNAKE_CASE (DEFAULT_DIMENSION)
- 泛型: 单字母大写 (T, E, K, V)

### 文档注释标准
```rust
/// 向量搜索结果结构体
/// 
/// 包含搜索到的文档信息和相关性分数
/// 
/// # 示例
/// ```rust
/// use grape_vector_db::SearchResult;
/// 
/// let result = SearchResult {
///     id: "document_123".to_string(),
///     score: 0.95,
///     document: Some(document),
///     metadata: HashMap::new(),
/// };
/// 
/// println!("文档 {} 的相关性: {}", result.id, result.score);
/// ```
/// 
/// # 注意
/// - score 范围为 0.0-1.0，1.0 表示完全匹配
/// - document 字段可能为 None，需要检查
pub struct SearchResult {
    /// 文档的唯一标识符
    pub id: String,
    /// 搜索相关性分数 (0.0-1.0)
    pub score: f32,
    /// 关联的完整文档对象  
    pub document: Option<Document>,
    /// 额外的元数据信息
    pub metadata: HashMap<String, Value>,
}
```

### 日志规范
使用tracing进行结构化日志:

```rust
use tracing::{info, warn, error, debug, instrument};

#[instrument(skip(self, vectors), fields(count = vectors.len()))]
pub async fn batch_insert_vectors(&self, vectors: Vec<(String, Vec<f32>)>) -> Result<()> {
    let start = Instant::now();
    info!("开始批量插入向量");
    
    // 实现逻辑...
    
    info!(
        count = vectors.len(),
        elapsed_ms = start.elapsed().as_millis(),
        "批量插入向量完成"
    );
    
    Ok(())
}
```

## 依赖管理原则

### 允许的依赖类型
- 核心运行时: tokio, async-trait
- 序列化: serde, postcard, prost
- 错误处理: thiserror, anyhow  
- 数学计算: nalgebra, ndarray
- 并发: parking_lot, crossbeam, dashmap
- 网络: tonic, reqwest
- 存储: sled
- 向量算法: instant-distance

### 禁止的依赖
- 重型机器学习框架 (candle暂时移除)
- 重型数据库 (rocksdb已移除)
- 不稳定的实验性库
- GPL许可证库

## 构建和部署

### 发布配置
```toml
[profile.release]
opt-level = 3           # 最高优化级别
lto = true             # 链接时优化
codegen-units = 1      # 单个代码生成单元
panic = "abort"        # panic时直接退出
strip = true           # 移除调试符号
```

### 特性标志管理
```toml
[features]
default = ["sled-backend", "hnsw-index", "embedding-cache"]
sled-backend = ["sled"]
hnsw-index = ["instant-distance"] 
embedding-cache = ["moka"]
distributed = []       # Phase 2功能
metrics = []           # 性能监控
```

## 兼容性和互操作

### API兼容性目标
- Qdrant REST API 兼容层
- OpenAI Embeddings API 兼容
- 标准向量格式支持 (numpy, faiss)

### 跨平台要求
- Windows 10+
- Linux (Ubuntu 20.04+, CentOS 8+)  
- macOS 11+
- Docker容器化支持

## AI助手工作指导

### 响应语言
- 所有回复使用简体中文
- 代码注释使用中文
- 错误信息支持中英双语

### 工作原则
1. 必须深入理解现有代码架构后再提供建议
2. 优先基于现有实现扩展，避免推倒重来
3. 提供多个技术方案并说明优缺点
4. 关注代码边界情况和异常处理
5. 重视代码可读性和维护性

### 代码生成要求
- 生成的代码必须能直接编译运行
- 包含完整的错误处理逻辑
- 添加详细的中文注释
- 符合项目的所有规范要求
- 不允许任何TODO或占位符

### 第三方库选择
在需要更换中间件或第三方库时，必须与用户交互式确认选择。 